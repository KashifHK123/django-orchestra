from django.core.exceptions import ValidationError
from django.db import models
from django.utils.functional import cached_property
from django.utils.translation import ugettext_lazy as _
from jsonfield import JSONField

from orchestra.core import accounts
from orchestra.models.queryset import group_by

from . import settings
from .methods import PaymentMethod


class PaymentSourcesQueryset(models.QuerySet):
    def get_default(self):
        return self.filter(is_active=True).first()


class PaymentSource(models.Model):
    account = models.ForeignKey('accounts.Account', verbose_name=_("account"),
            related_name='paymentsources')
    method = models.CharField(_("method"), max_length=32,
            choices=PaymentMethod.get_plugin_choices())
    data = JSONField(_("data"))
    is_active = models.BooleanField(_("active"), default=True)
    
    objects = PaymentSourcesQueryset.as_manager()
    
    def __unicode__(self):
        return "%s (%s)" % (self.label, self.method_class.verbose_name)
    
    @cached_property
    def method_class(self):
        return PaymentMethod.get_plugin(self.method)
    
    @cached_property
    def label(self):
        return self.method_class().get_label(self.data)
    
    @cached_property
    def number(self):
        return self.method_class().get_number(self.data)
    
    def get_bill_context(self):
        method = self.method_class()
        return {
            'message': method.get_bill_message(self),
        }
    
    def get_due_delta(self):
        return self.method_class().due_delta
    
    def clean(self):
        self.data = self.method_class().clean_data(self.data)


class TransactionQuerySet(models.QuerySet):
    group_by = group_by
    
    def create(self, **kwargs):
        source = kwargs.get('source')
        if source is None or not hasattr(source.method_class, 'process'):
            # Manual payments don't need processing
            kwargs['state']=self.model.WAITTING_EXECUTION
        return super(TransactionQuerySet, self).create(**kwargs)
    
    def secured(self):
        return self.filter(state=Transaction.SECURED)
    
    def exclude_rejected(self):
        return self.exclude(state=Transaction.REJECTED)
    
    def amount(self):
        return self.aggregate(models.Sum('amount')).values()[0]
    
    def processing(self):
        return self.filter(state__in=[Transaction.EXECUTED, Transaction.WAITTING_EXECUTION])


class Transaction(models.Model):
    WAITTING_PROCESSING = 'WAITTING_PROCESSING' # CREATED
    WAITTING_EXECUTION = 'WAITTING_EXECUTION' # PROCESSED
    EXECUTED = 'EXECUTED'
    SECURED = 'SECURED'
    REJECTED = 'REJECTED'
    STATES = (
        (WAITTING_PROCESSING, _("Waitting processing")),
        (WAITTING_EXECUTION, _("Waitting execution")),
        (EXECUTED, _("Executed")),
        (SECURED, _("Secured")),
        (REJECTED, _("Rejected")),
    )
    
    bill = models.ForeignKey('bills.bill', verbose_name=_("bill"),
            related_name='transactions')
    source = models.ForeignKey(PaymentSource, null=True, blank=True,
            verbose_name=_("source"), related_name='transactions')
    process = models.ForeignKey('payments.TransactionProcess', null=True,
            blank=True, verbose_name=_("process"), related_name='transactions')
    state = models.CharField(_("state"), max_length=32, choices=STATES,
            default=WAITTING_PROCESSING)
    amount = models.DecimalField(_("amount"), max_digits=12, decimal_places=2)
    currency = models.CharField(max_length=10, default=settings.PAYMENT_CURRENCY)
    created_at = models.DateTimeField(_("created"), auto_now_add=True)
    modified_at = models.DateTimeField(_("modified"), auto_now=True)
    
    objects = TransactionQuerySet.as_manager()
    
    def __unicode__(self):
        return "Transaction #{}".format(self.id)
    
    @property
    def account(self):
        return self.bill.account
    
    def clean(self):
        if not self.pk:
            amount = self.bill.transactions.exclude(state=self.REJECTED).amount()
            if amount >= self.bill.total:
                raise ValidationError(_("New transactions can not be allocated for this bill."))
    
    def mark_as_processed(self):
        assert self.state == self.WAITTING_PROCESSING
        self.state = self.WAITTING_EXECUTION
        self.save(update_fields=['state'])
    
    def mark_as_executed(self):
        assert self.state == self.WAITTING_EXECUTION
        self.state = self.EXECUTED
        self.save(update_fields=['state'])
    
    def mark_as_secured(self):
        assert self.state == self.EXECUTED
        self.state = self.SECURED
        self.save(update_fields=['state'])
    
    def mark_as_rejected(self):
        assert self.state == self.EXECUTED
        self.state = self.REJECTED
        self.save(update_fields=['state'])


class TransactionProcess(models.Model):
    """
    Stores arbitrary data generated by payment methods while processing transactions
    """
    CREATED = 'CREATED'
    EXECUTED = 'EXECUTED'
    ABORTED = 'ABORTED'
    COMMITED = 'COMMITED'
    STATES = (
        (CREATED, _("Created")),
        (EXECUTED, _("Executed")),
        (ABORTED, _("Aborted")),
        (COMMITED, _("Commited")),
    )
    
    data = JSONField(_("data"), blank=True)
    file = models.FileField(_("file"), blank=True)
    state = models.CharField(_("state"), max_length=16, choices=STATES, default=CREATED)
    created_at = models.DateTimeField(_("created"), auto_now_add=True)
    updated_at = models.DateTimeField(_("updated"), auto_now=True)
    
    class Meta:
        verbose_name_plural = _("Transaction processes")
    
    def __unicode__(self):
        return '#%i' % self.id
    
    def mark_as_executed(self):
        assert self.state == self.CREATED
        self.state = self.EXECUTED
        for transaction in self.transactions.all():
            transaction.mark_as_executed()
        self.save(update_fields=['state'])
    
    def abort(self):
        assert self.state in [self.CREATED, self.EXCECUTED]
        self.state = self.ABORTED
        for transaction in self.transaction.all():
            transaction.mark_as_aborted()
        self.save(update_fields=['state'])
    
    def commit(self):
        assert self.state in [self.CREATED, self.EXECUTED]
        self.state = self.COMMITED
        for transaction in self.transactions.processing():
            transaction.mark_as_secured()
        self.save(update_fields=['state'])


accounts.register(PaymentSource)
accounts.register(Transaction)
